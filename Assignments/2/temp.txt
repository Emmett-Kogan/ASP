FIFO_push Algorithm:
	Check semaphore value to see if full, if not full proceed, otherwise return 1
	Copy data from tail pointer to buffer provided by caller
	Update tail pointer and semaphore and return

FIFO_pop Algorithm:
	Aquire FIFO lock
	Wait on semaphore for data to be available (i.e. sem val > 0)
	Copy data from head pointer and update head pointer
	Release FIFO lock

If both are occuring at the same time, the only thing not mutually exclusive is the count semaphore
I'm assuming that this is for 1 producer, and multiple consumers

The only time that head and tail are the same is if the FIFO is full, OR, if the FIFO is empty. If the 
FIFO is full, then the writer cannot modify the piece of member. However, if the pop waits on the 
semaphore just before push, then push may write to the same spot that pop is copying from. And I think 
that's the only race condition. Because in every other case, the would be offender either gets blocked or 
is wowrking on a different part of the buffer.

So I think my options are to change how push works. Now the problem is around how I deal with the count value...
Maybe if it count is non-zero I try to grab the lock so in the case.

This is the main errata and possible fix to ask Yavuz about:
Between the sem_wait in pop and the memcpy lines, if the thread is blocked, then a push call COULD get 
past the bounds check of the semaphore. In order to prevent this, I could make an additional condition 
where the push function must pick up the lock as well when the FIFO is nearly full or at count-1 so that 
a read and write at the same memory location is impossible. Since the mutex is already held by the 
blocked thread, then the writer will be blocked until after the read is finished, and will be able to 
write the data, before another read can begin.
